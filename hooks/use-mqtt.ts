"use client"

import { useState, useEffect, useCallback, useRef } from "react"
import mqtt from "mqtt"
import { useToast } from "@/hooks/use-toast"

interface BMSData {
  timestamp?: number
  pack_voltage?: number
  current?: number
  power?: number
  soc?: number
  remaining_capacity?: number
  cycle_count?: number
  temperature1?: number
  temperature2?: number
  charge_enabled?: boolean
  discharge_enabled?: boolean
  cell_voltages?: number[]
  alarms?: {
    overvoltage?: boolean
    undervoltage?: boolean
    overcurrent_charge?: boolean
    overcurrent_discharge?: boolean
    overtemperature?: boolean
    undertemperature?: boolean
  }
}

interface SystemStatus {
  timestamp?: number
  wifi_connected?: boolean
  mqtt_connected?: boolean
  bms_connected?: boolean
  wifi_rssi?: number
  free_heap?: number
  uptime?: number
  mqtt_pub_count?: number
  mqtt_fail_count?: number
}

interface ConnectionStatus {
  mqtt: boolean
  reconnecting: boolean
  reconnectCount: number
  messageCount: number
  lastError?: string
}

// ‚úÖ FIXED: Correct HiveMQ Cloud WebSocket configuration
const MQTT_CONFIG = {
  broker: "wss://800183b566f44f8b814485f15e6f0a9d.s1.eu.hivemq.cloud:8884/mqtt",
  username: "0971969218",
  password: "Bmkjk0971969218",
  topics: {
    data: "bms/data",
    status: "bms/status",
    control: "bms/control",
  },
}

// ‚úÖ ADDED: Alternative connection configurations to try
const FALLBACK_CONFIGS = [
  {
    broker: "wss://800183b566f44f8b814485f15e6f0a9d.s1.eu.hivemq.cloud:8884/mqtt",
    name: "Primary WebSocket",
  },
  {
    broker: "wss://800183b566f44f8b814485f15e6f0a9d.s1.eu.hivemq.cloud:8884/",
    name: "Alternative WebSocket",
  },
]

export function useMQTT() {
  const [bmsData, setBmsData] = useState<BMSData | null>(null)
  const [systemStatus, setSystemStatus] = useState<SystemStatus | null>(null)
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>({
    mqtt: false,
    reconnecting: false,
    reconnectCount: 0,
    messageCount: 0,
  })
  const [lastUpdate, setLastUpdate] = useState<number | null>(null)

  const clientRef = useRef<mqtt.MqttClient | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const currentConfigIndexRef = useRef<number>(0)
  const lastCommandTimeRef = useRef<number>(0)
  const { toast } = useToast()

  // Rate limiting for commands
  const canSendCommand = useCallback(() => {
    const now = Date.now()
    if (now - lastCommandTimeRef.current < 1000) {
      return false
    }
    lastCommandTimeRef.current = now
    return true
  }, [])

  const connect = useCallback(() => {
    if (clientRef.current?.connected) {
      return
    }

    const currentConfig = FALLBACK_CONFIGS[currentConfigIndexRef.current] || FALLBACK_CONFIGS[0]

    console.log(`üîÑ Attempting MQTT connection (${currentConfig.name})...`)
    console.log(`üîó Broker: ${currentConfig.broker}`)
    console.log(`üë§ Username: ${MQTT_CONFIG.username}`)

    setConnectionStatus((prev) => ({
      ...prev,
      reconnecting: true,
      lastError: undefined,
    }))

    try {
      // Clean up existing client
      if (clientRef.current) {
        clientRef.current.removeAllListeners()
        clientRef.current.end(true)
        clientRef.current = null
      }

      // ‚úÖ FIXED: Optimized connection options for HiveMQ Cloud
      const client = mqtt.connect(currentConfig.broker, {
        username: MQTT_CONFIG.username,
        password: MQTT_CONFIG.password,
        keepalive: 60,
        connectTimeout: 20000, // Increased timeout
        reconnectPeriod: 0, // Disable auto-reconnect, we'll handle it manually
        clean: true,
        clientId: `bms_web_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        protocolVersion: 4,
        // ‚úÖ ADDED: WebSocket specific options
        transformWsUrl: (url, options, client) => {
          console.log(`üåê WebSocket URL: ${url}`)
          return url
        },
      })

      // ‚úÖ ADDED: Connection timeout handler
      const connectionTimeout = setTimeout(() => {
        console.log("‚è∞ Connection timeout - trying next configuration")
        client.end(true)

        // Try next configuration
        currentConfigIndexRef.current = (currentConfigIndexRef.current + 1) % FALLBACK_CONFIGS.length

        setConnectionStatus((prev) => ({
          ...prev,
          reconnecting: false,
          lastError: `Timeout with ${currentConfig.name}`,
        }))

        // Retry with next config after delay
        setTimeout(() => connect(), 2000)
      }, 25000) // 25 second timeout

      client.on("connect", (connack) => {
        clearTimeout(connectionTimeout)
        console.log("‚úÖ MQTT Connected successfully!")
        console.log("üéâ Connection details:", connack)

        // Reset config index on successful connection
        currentConfigIndexRef.current = 0

        setConnectionStatus((prev) => ({
          ...prev,
          mqtt: true,
          reconnecting: false,
          reconnectCount: prev.reconnectCount + 1,
          lastError: undefined,
        }))

        // Subscribe to topics with delay
        setTimeout(() => {
          const topics = [MQTT_CONFIG.topics.data, MQTT_CONFIG.topics.status]
          console.log("üì° Subscribing to topics:", topics)

          client.subscribe(topics, { qos: 0 }, (err, granted) => {
            if (err) {
              console.error("‚ùå Subscribe error:", err)
              toast({
                title: "L·ªói ƒëƒÉng k√Ω topic",
                description: `Kh√¥ng th·ªÉ ƒëƒÉng k√Ω: ${err.message}`,
                variant: "destructive",
              })
            } else {
              console.log("‚úÖ Successfully subscribed:", granted)
              toast({
                title: "K·∫øt n·ªëi th√†nh c√¥ng",
                description: `ƒê√£ k·∫øt n·ªëi ${currentConfig.name}`,
              })
            }
          })
        }, 1000)
      })

      client.on("message", (topic, message) => {
        try {
          if (message.length > 2048) {
            console.warn("‚ö†Ô∏è  Message too large, truncating")
            return
          }

          const data = JSON.parse(message.toString())

          // ‚úÖ ADDED: Debug logs ƒë·ªÉ ki·ªÉm tra
          console.log(`üì® Received topic: ${topic}`)
          console.log(`üìä Message data:`, data)

          setConnectionStatus((prev) => ({
            ...prev,
            messageCount: prev.messageCount + 1,
          }))

          if (topic === MQTT_CONFIG.topics.data) {
            console.log("üìä BMS Data received:", data)
            setBmsData(data)
            setLastUpdate(Date.now())
          } else if (topic === MQTT_CONFIG.topics.status) {
            console.log("üì° System status received:", data)
            setSystemStatus(data)
          }
        } catch (error) {
          console.error("‚ùå Error parsing message:", error)
        }
      })

      client.on("error", (error) => {
        clearTimeout(connectionTimeout)
        console.error("‚ùå MQTT Error:", error)

        const errorMessage = error.message || error.toString()
        setConnectionStatus((prev) => ({
          ...prev,
          mqtt: false,
          reconnecting: false,
          lastError: errorMessage,
        }))

        // Handle specific error types
        if (errorMessage.includes("connack timeout")) {
          console.log("üîÑ CONNACK timeout - trying next configuration")
          currentConfigIndexRef.current = (currentConfigIndexRef.current + 1) % FALLBACK_CONFIGS.length

          toast({
            title: "Timeout k·∫øt n·ªëi",
            description: "ƒêang th·ª≠ c·∫•u h√¨nh kh√°c...",
            variant: "destructive",
          })

          // Retry with next config
          setTimeout(() => connect(), 3000)
        } else if (errorMessage.includes("Connection refused")) {
          toast({
            title: "K·∫øt n·ªëi b·ªã t·ª´ ch·ªëi",
            description: "Ki·ªÉm tra th√¥ng tin ƒëƒÉng nh·∫≠p",
            variant: "destructive",
          })
        } else {
          toast({
            title: "L·ªói k·∫øt n·ªëi MQTT",
            description: errorMessage,
            variant: "destructive",
          })
        }
      })

      client.on("close", () => {
        clearTimeout(connectionTimeout)
        console.log("üîå MQTT Connection closed")
        setConnectionStatus((prev) => ({ ...prev, mqtt: false, reconnecting: false }))
      })

      client.on("disconnect", (packet) => {
        clearTimeout(connectionTimeout)
        console.log("üíî MQTT Disconnected:", packet)
        setConnectionStatus((prev) => ({ ...prev, mqtt: false }))
      })

      client.on("offline", () => {
        console.log("üì¥ MQTT Offline")
        setConnectionStatus((prev) => ({ ...prev, mqtt: false }))
      })

      clientRef.current = client
    } catch (error) {
      console.error("‚ùå MQTT Connection setup error:", error)
      setConnectionStatus((prev) => ({
        ...prev,
        mqtt: false,
        reconnecting: false,
        lastError: error instanceof Error ? error.message : "Setup error",
      }))

      // Retry with exponential backoff
      const backoffTime = Math.min(30000, 3000 * Math.pow(2, Math.min(connectionStatus.reconnectCount, 3)))
      console.log(`üîÑ Will retry in ${backoffTime}ms`)

      reconnectTimeoutRef.current = setTimeout(() => {
        connect()
      }, backoffTime)
    }
  }, [toast, connectionStatus.reconnectCount])

  const sendCommand = useCallback(
    (command: string, value?: boolean) => {
      if (!clientRef.current?.connected) {
        console.log("‚ùå Cannot send command - MQTT not connected")
        toast({
          title: "Kh√¥ng th·ªÉ g·ª≠i l·ªánh",
          description: "Ch∆∞a k·∫øt n·ªëi ƒë·∫øn h·ªá th·ªëng BMS",
          variant: "destructive",
        })
        return false
      }

      if (!canSendCommand()) {
        console.log("‚ö†Ô∏è  Command rate limited")
        toast({
          title: "G·ª≠i l·ªánh qu√° nhanh",
          description: "Vui l√≤ng ch·ªù 1 gi√¢y gi·ªØa c√°c l·ªánh",
          variant: "destructive",
        })
        return false
      }

      const payload = {
        command,
        value: value !== undefined ? value : true,
        timestamp: Date.now(),
      }

      console.log(`üì§ Sending command: ${command} = ${value}`)

      clientRef.current.publish(
        MQTT_CONFIG.topics.control,
        JSON.stringify(payload),
        { qos: 0, retain: false },
        (error) => {
          if (error) {
            console.error("‚ùå Error sending command:", error)
            toast({
              title: "L·ªói g·ª≠i l·ªánh",
              description: `Kh√¥ng th·ªÉ g·ª≠i l·ªánh ${command}`,
              variant: "destructive",
            })
          } else {
            console.log("‚úÖ Command sent successfully")
            toast({
              title: "G·ª≠i l·ªánh th√†nh c√¥ng",
              description: `ƒê√£ g·ª≠i l·ªánh ${command}`,
            })
          }
        },
      )

      return true
    },
    [toast, canSendCommand],
  )

  // Initialize connection
  useEffect(() => {
    console.log("üöÄ Initializing MQTT connection...")
    connect()

    return () => {
      console.log("üßπ Cleaning up MQTT connection...")
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
      if (clientRef.current) {
        clientRef.current.removeAllListeners()
        clientRef.current.end(true)
      }
    }
  }, [connect])

  // Health check with manual reconnection
  useEffect(() => {
    const healthCheck = setInterval(() => {
      if (!connectionStatus.mqtt && !connectionStatus.reconnecting) {
        console.log("üè• Health check: Attempting reconnection")
        connect()
      }
    }, 45000) // Check every 45 seconds

    return () => clearInterval(healthCheck)
  }, [connect, connectionStatus.mqtt, connectionStatus.reconnecting])

  return {
    bmsData,
    systemStatus,
    connectionStatus,
    sendCommand,
    isConnected: connectionStatus.mqtt,
    lastUpdate,
  }
}
